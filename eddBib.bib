@inproceedings{Chis15a,
     abstract={Object inspectors are an essential category of tools that allow developers to comprehend the run-time of object-oriented systems. Traditional object inspectors favor a generic view that focuses on the low-level details of the state of single objects. Based on 16 interviews with software developers and a follow-up survey with 62 respondents we identified a need for object inspectors that support different high-level ways to visualize and explore objects, depending on both the object and the current developer need. We propose the Moldable Inspector, a novel inspector model that enables developers to adapt the inspection workflow to suit their immediate needs by making the inspection context explicit, providing multiple interchangeable domain-specific views for each object, and supporting  a workflow that groups together multiple levels of connected objects. We show that the Moldable Inspector can address multiple kinds of development needs involving a wide range of objects.},
	 author = {Andrei Chi\c{s} and Tudor G\^irba and Oscar Nierstrasz and Aliaksei Syrel},
	 title = {The {Moldable} {Inspector}},
	 booktitle = {Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
	Annote = {internationalconference},
	 series = {Onward! 2015},
	 year = {2015},
	 location = {Pittsburgh, PA, USA},
	 pages = {44--60},
	 numpages = {17},
	 url = {http://scg.unibe.ch/archive/papers/Chis15a-MoldableInspector.pdf},
	 doi = {10.1145/2814228.2814234},
	 isbn = {978-1-4503-3688-8},
	 acmid = {2814234},
	 publisher = {ACM},
	 address = {New York, NY, USA},
	 keywords = {scg-pub scg15 jb16 snf-asa1, Andrei Chis, Tudor Girba, girba feenk-pub},
	 peerreview = {yes},
	 medium = {2}
}

@inproceedings{Chis15b,
	Annote = {internationalworkshop},
	abstract={Understanding the run-time behaviour of object-oriented applications entails the comprehension of run-time objects. Traditional object inspectors favor generic views that focus on the low-level details of the state of single objects. While universally applicable, this generic approach does not take into account the varying needs of developers that could benefit from tailored views and exploration possibilities. GTInspector is a novel moldable object inspector that provides different high-level ways to visualize and explore objects, adapted to both the object and the current developer need. More information about the GTInspector can be found at: scg.unibe.ch/research/moldableinspector},
	author = {Andrei Chi\c{s} and Tudor G\^irba and Oscar Nierstrasz and Aliaksei Syrel},
	title={{GTInspector}: A Moldable Domain-Aware Object Inspector},
	booktitle = {Proceedings of the Companion Publication of the 2015 ACM SIGPLAN Conference on Systems, Programming, and Applications: Software for Humanity},
	series = {SPLASH Companion 2015},
	year = {2015},
	location = {Pittsburgh, PA, USA},
	pages = {15--16},
	numpages = {2},
	url = {http://scg.unibe.ch/archive/papers/Chis15b-GTInspector.pdf},
	doi = {10.1145/2814189.2814194},
	isbn = {978-1-4503-3722-9},
	acmid = {2814194},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {scg-pub scg15 jb16 snf-asa1, Andrei Chis, Tudor Girba, girba feenk-pub},
	peerreview = {yes},
	medium = {2}
}

@article{Chis15c,
	abstract = {Understanding the run-time behavior of software systems can be a challenging activity. Debuggers are an essential category of tools used for this purpose as they give developers direct access to the running systems. Nevertheless, traditional debuggers rely on generic mechanisms to introspect and interact with the running systems, while developers reason about and formulate domain-specific questions using concepts and abstractions from their application domains. This mismatch creates an abstraction gap between the debugging needs and the debugging support leading to an inefficient and error-prone debugging effort, as developers need to recover concrete domain concepts using generic mechanisms. To reduce this gap, and increase the efficiency of the debugging process, we propose a framework for developing domain-specific debuggers, called the Moldable Debugger, that enables debugging at the level of the application domain. The Moldable Debugger is adapted to a domain by creating and combining domain-specific debugging operations with domain-specific debugging views, and adapts itself to a domain by selecting, at run time, appropriate debugging operations and views. To ensure the proposed model has practical applicability (i.e., can be used in practice to build real debuggers), we discuss, from both a performance and usability point of view, three implementation strategies. We further motivate the need for domain-specific debugging, identify a set of key requirements and show how our approach improves debugging by adapting the debugger to several domains.},
	title = {Practical Domain-specific Debuggers using the {Moldable Debugger} framework},
	journal = {Computer Languages, Systems \& Structures},
	volume = {44, Part A},
	pages = {89--113},
	year = {2015},
	Annote = {internationaljournal},
	note = {Special issue on the 6th and 7th International Conference on Software Language Engineering ({SLE} 2013 and {SLE} 2014)},
	issn = {1477-8424},
	doi = {10.1016/j.cl.2015.08.005},
	url = {http://scg.unibe.ch/archive/papers/Chis15c-PracticalDomainSpecificDebuggers.pdf},
	peerReview = {yes},
	author = {Andrei Chi\c{s} and Marcus Denker and Tudor G\^irba and Oscar Nierstrasz},
	medium = {2},
	keywords = {scg-pub scg15 jb16 snf-asa1 Andrei Chis, Tudor Girba, Debugging, Customization, Domain-specific tools, User interfaces, Programming environments, Smalltalk, girba feenk-pub}
}

@inproceedings{Chis15d,
	Abstract = {Developers commonly ask detailed and domain-specific questions about the software systems they are developing and maintaining. Integrated development environments (IDEs) form an essential category of tools for developing software that should support software engineering decision making. Unfortunately, rigid and generic IDEs that focus on low-level programming tasks, that promote code rather than data, and that suppress customization, offer limited support for informed decision making during software development. We propose to improve decision making within IDEs by moving from generic to context-aware IDEs through moldable tools. In this paper, we promote the idea of moldable tools, illustrate it with concrete examples, and discuss future research directions.},
	Author = {Andrei Chi\c{s} and Tudor G\^{i}rba and Oscar Nierstrasz},
	booktitle = {Proceedings of the 6th Workshop on Evaluation and Usability of Programming Languages and Tools},
    series = {PLATEAU '15},
	doi = {10.1145/2846680.2846684},
	Keywords = {scg-pub scg15 jb16 snf-asa1, internationalworkshop, Andrei Chis,Tudor Girba, girba feenk-pub},
	location = {Pittsburgh, PA, USA},
	Peerreview = {yes},
	medium = {2},
	Title = {Towards Moldable Development Tools},
	Url = {http://scg.unibe.ch/archive/papers/Chis15d_TowardsMoldableDevelopmentTools.pdf},
	Year = {2015},
	isbn = {978-1-4503-3907-0},
	pages = {25--26},
	acmid = {2846684},
	publisher = {ACM},
	address = {New York, NY, USA}
}

@inproceedings{Chis16a,
	Abstract = {Software systems involve many different kinds of domain-specific and interrelated software entities.
A common strategy employed by developers to deal with this reality is to perform exploratory investigations by means of searching.
Nevertheless, most integrated development environments (IDEs) support searching through generic and disconnected search tools.
This impedes search tasks over domain-specific entities as considerable effort is wasted by developers locating and linking data and concepts relevant to their application domains. To tackle this problem we propose Spotter, a moldable framework for supporting contextual-aware searching in IDEs by enabling developers to easily create custom searches for domain objects.  In this paper we motivate a set of requirements for Spotter and show, through usage scenarios, that Spotter improves program comprehension by reducing the effort required to find and search through concepts from a wide range of domains. Furthermore, we show that by taking code into account, Spotter can provide a single entry point for embedding search support within an IDE.},
	Author = {Andrei Chi\c{s} and Tudor G\^irba and Juraj Kubelka and Oscar Nierstrasz and Stefan Reichhart and Aliaksei Syrel},
	Booktitle = {Proceedings of the 2016 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
	Annote = {internationalconference},
	Series = {Onward! 2016},
	Title = {Moldable, Context-aware searching with {Spotter}},
	Doi = {10.1145/2986012.2986023},
	pages = {128--144},
	Numpages = {17},
	Location = {Amsterdam, Netherlands},
	Year = {2016},
	Peerreview = {yes},
	Medium = {2},
	Publisher = {ACM},
	Keywords = {scg-pub scg16 jb17 snf-asa2 Andrei Chis, Spotter, Tudor Girba, girba feenk-pub},
	Url = {http://scg.unibe.ch/archive/papers/Chis16a-MoldableContextAwareSearchingWithSpotter.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Chis16a-MoldableContextAwareSearchingWithSpotter.pdf},
	Address = {New York, NY, USA}}

@inproceedings{Chis16b,
	Abstract = {Developing and evolving software requires developers to continuously make decisions about how to steer the design and implementation of their applications. To make informed decisions developers commonly formulate detailed and domain-specific questions about their software systems and  use tools to explore available information and answer those questions. Development tools however focus on generic programming tasks while program comprehension and analysis tools typically are not tightly integrated with their development tools and environments. This  has a negative effect on program comprehension as it increases the effort and the time needed to obtain an answer. To improve program comprehension we propose that developers build software using development tools tailored to their specific application domains, as this can directly answer domain-specific questions. We introduce moldable development as an approach for developing software in which developers evolve development tools together with their applications.  In this paper we sketch the idea of moldable development and give examples to illustrate how it can be applied in practice. Through these examples we show that given a low cost for extending development tools, developers can create relevant and useful customizations to help them evolve their own applications.},
	Annote = {internationalworkshop},
	Author = {Andrei Chi\c{s} and Tudor G\^irba and Juraj Kubelka and Oscar Nierstrasz and Stefan Reichhart and Aliaksei Syrel},
	Booktitle = {Proceedings of the Programming Experience 2016 (PX/16) Workshop},
 	Series = {PX/16},
	Location={Rome, Italy},
	Title = {Exemplifying Moldable Development},
	Doi = {10.1145/2984380.2984385},
	Isbn = {978-1-4503-4776-1},
	Pages= {33--42},
	Numpages = {10},
	Year = {2016},
	Peerreview = {yes},
	Medium = {2},
        Acmid = {2984385},
	Publisher = {ACM},
	Address = {New York, NY, USA},
	Language={English},
	Url = {http://scg.unibe.ch/archive/papers/Chis16b-ExemplifyingMoldableDevelopment.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Chis16b-ExemplifyingMoldableDevelopment.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2984380.2984385},
	Keywords = {scg-pub, snf-asa2, scg16, jb16, internationalworkshop, Andrei Chis, Domain-specific tools, User interfaces, Programming environments, Program comprehension, Tudor Girba, girba feenk-pub}
}

@incollection{Chis17a,
	Abstract = {Object-oriented programming aims to facilitate navigation between domain concepts and the code that addresses those domains by enabling developers to directly model those domain concepts in the code. To make informed decisions developers then  formulate detailed and domain-specific questions about their systems in terms of domain concepts, and use tools to explore available information and answer those questions. Development tools however focus mainly on object-oriented idioms and do not expose or exploit domain concepts constructed on top of object-oriented programming idioms. Analysis tools are typically not tightly integrated with development tools. This has a negative effect on program comprehension, increasing the effort and the time for obtaining answers. To improve program comprehension we propose to better integrate domain concepts and program comprehension tools into the development environment through moldable tools. Moldable tools are development tools that are aware of the current development context and support inexpensive creation of domain-specific extensions. We elaborate on the idea of moldable tools and show how to apply moldable tools to support object-oriented programming. Through practical examples we show how developers can embed domain concepts into their development tools.},
	Author = {Andrei Chi\c{s} and Tudor G\^irba and Juraj Kubelka and Oscar Nierstrasz and Stefan Reichhart and Aliaksei Syrel},
	Booktitle = {PAUSE: Present And Ulterior Software Engineering},
	Editor = {Manuel Mazzara, Bertrand Meyer},
	Title = {Moldable Tools for Object-Oriented Development},
	Pages= {77--101},
	Publisher = {Springer, Cham},
	Doi = {10.1007/978-3-319-67425-4_6},
	Peerreview = {yes},
	Medium = {2},
	Keywords = {scg-pub snf-asa2 scg17 jb18, Andrei Chis, Tudor Girba, girba feenk-pub},
	Url = {http://scg.unibe.ch/archive/papers/Chis17a-MoldableToolsPAUSE.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Chis16c-MoldableToolsPAUSE.pdf},
	Bdsk-Url-2 = {https://link.springer.com/chapter/10.1007/978-3-319-67425-4_6},
	Year = {2017}}

@techreport{Girb17a,
    Author  = {Tudor G\^irba},
    Title   = {Humane Assessment by Example},
    Institution = {feenk.com},
    Url = {http://humane-assessment.com/res/humane-assessment-case-studies-a4.pdf},
    keywords = {girba Tudor Girba feenk-pub},
    Year    = {2017}
}

@misc{Girb19a,
	Author = {Tudor G\^irba},
	Keywords = {gtoolkit examples girba feenk-pub},
	Title = {An Example of Example-driven Development},
	Url = {https://medium.com/feenk/an-example-of-example-driven-development-4dea0d995920},
	Year = {2019}
}

@misc{Girb20a,
	Author = {Tudor G\^irba},
	Keywords = {gtoolkit graphics brick bloc girba feenk-pub},
	Title = {One Rendering Tree},
	Url = {https://medium.com/feenk/one-rendering-tree-918eae49bcff},
	Year = {2020}
}

@misc{Girb21a,
	Author = {Tudor G\^irba},
	Keywords = {gtoolkit lepiter girba feenk-pub},
	Title = {Introducing {Lepiter}: Knowledge Management + Multi-language Notebooks + Moldable Development},
	Url = {https://lepiter.io/feenk/introducing-lepiter--knowledge-management--e2p6apqsz5npq7m4xte0kkywn/},
	Year = {2021}
}

@inproceedings{Kube15a,
	 Abstract = {Analyzing how software engineers use the Integrated Development Environment (IDE) is essential to better understanding how engineers carry out their daily tasks. Spotter is a code search engine for the Pharo programming language. Since its inception, Spotter has been rapidly and broadly adopted within the Pharo community. However, little is known about how practitioners employ Spotter to search and navigate within the Pharo code base. This paper evaluates how software engineers use Spotter in practice. To achieve this, we remotely gather user actions called events. These events are then visually rendered using an adequate navigation tool chain. Sequences of events are represented using a visual alphabet. We found a number of usage patterns and identified underused Spotter features. Such findings are essential for improving Spotter.},
	 Author = {Kubelka, Juraj and Bergel, Alexandre and Chi\c{s}, Andrei and G\^irba, Tudor and Reichhart, Stefan and Robbes, Romain and Syrel, Aliaksei},
	 Booktitle = {Proceedings of 3rd IEEE Working Conference on Software Visualization - New Ideas and Emerging Results},
	 Pages = {145--149},
	 Publisher = {{IEEE}},
	 Series = {VISSOFT-NIER'15},
	 Doi={10.1109/VISSOFT.2015.7332426},
	 Title = {On Understanding How Developers Use the {Spotter} Search Tool},
	 Year = {2015},
	 month=sep,
 	 Peerreview = {yes},
	 Medium = {2},
	 Keywords = {scg-pub scg15 jb16 snf-asa1, Andrei Chis, Tudor Girba, girba feenk-pub},
	 Url = {http://scg.unibe.ch/archive/papers/Kube15a-OnUnderstandingHowDevelopersUseTheSpotterSearchTool.pdf}}

@inproceedings{Nier22a,
    Author    = {Oscar Nierstrasz and Tudor G\^irba},
    Title     = {Making Systems Explainable},
    Booktitle = {{VISSOFT}'22: Proceedings of the 10th IEEE Working Conference on Software Visualization},
    Abstract  = {What makes software systems explainable? As we develop
      and maintain software, we have questions to ask about
      the code, but piecing together the answers remains hard.
      The main interface the classical IDE offers is a text
      editor for the source code. Code, documentation, and the
      running system are disconnected. In this keynote
      presentation, we will show how software systems can be
      made explainable with the help of three interacting
      technologies: (i) live notebooks that can be used to
      create narratives that link documentation, source code,
      and running applications, (ii) example methods that not
      only perform tests, but produce live examples that can
      be used within narratives, to explain use cases,
      scenarios and features, and (iii) a moldable inspector
      that can be easily extended with live custom views to
      answer domain-specific questions about software systems.
      With the help of running examples we will show in the
      keynotes presentation how these technologies work
      together to provide a radically different kind of
      development experience.},
    Annote    = {internationalconference},
    Keywords  = {feenk-pub girba},
    Url = {http://scg.unibe.ch/archive/papers/Nier22a-ExplainableSystems.pdf},
    DOI = {10.1109/VISSOFT55257.2022.00009},
    Publisher = {IEEE},
    PeerReview = {yes},
    Medium = {2},
    Year = {2022}
}

@misc{Nier23a,
	Author = {Oscar Nierstrasz},
	Title = {Mind the Gap --- 50 Years of Shortening Feedback Loops},
	howpublished = {Blog post},
	month = jun,
	year = {2023},
	Keywords = {feenk-pub lowRoad},
	Url = {https://www.oscar.nierstrasz.org/posts/2023-06-12-MindTheGap}
}

@inproceedings{Syre15a,
	 abstract={Program comprehension requires developers to reason about many kinds of highly interconnected software entities. Dealing with this reality prompts developers to continuously intertwine searching and navigation. Nevertheless, most integrated development environments (IDEs) address searching by means of many disconnected search tools, making it difficult for developers to reuse search results produced by one search tool as input for another search tool. This forces developers to spend considerable time manually linking disconnected search results. To address this issue we propose Spotter, a model for expressing and combining search tools in a unified way. The current implementation shows that Spotter can unify a wide range of search tools. More information about Spotter can be found at scg.unibe.ch/research/moldablespotter},
	 author = {Aliaksei Syrel and Andrei Chi\c{s} and Tudor G\^irba and Juraj Kubelka and Oscar Nierstrasz and Stefan Reichhart},
	 title = {Spotter: Towards a Unified Search Interface in {IDEs}},
 	 booktitle = {Proceedings of the Companion Publication of the 2015 ACM SIGPLAN Conference on Systems, Programming, and Applications: Software for Humanity},
	 series = {SPLASH Companion 2015},
	 year = {2015},
	 location = {Pittsburgh, PA, USA},
	 pages = {54--55},
	 numpages = {2},
	 url = {http://scg.unibe.ch/archive/papers/Syre15a-SpotterPosterAbstract.pdf},
	 doi = {10.1145/2814189.2817269},
	 isbn = {978-1-4503-3722-9},
	 acmid = {2817269},
	 publisher = {ACM},
	 address = {New York, NY, USA},
	 keywords = {snf-asa1, scg-pub scg15 jb16, Andrei Chis, Tudor Girba, girba feenk-pub},
	 peerreview = {yes},
	 medium = {2}
}

@inproceedings{Vale23a,
	Author = {Pablo Valenzuela-Toledo and Alexandre Bergel and Timo Kehrer and Oscar Nierstrasz},
	Title = {{EGAD}: A moldable tool for {GitHub} Action analysis},
	booktitle = {Proceedings of the 14th International Conference on Mining Software Repositories},
	  Annote    = {internationalconference},
	series = {MSR '23},
	year = {2023},
	location = {Melbourne, Australia},
	Keywords = {seg-pub feenk-pub jb23},
	Url = {http://scg.unibe.ch/archive/papers/Vale23a.pdf},
	DOI = {10.1109/MSR59073.2023.00044},
	PeerReview = {yes},
	Medium = {2},
	abstract = {GitHub Actions (GA) enjoy increasing popularity in many software
		development projects as a means to automate repetitive software
		engineering tasks by enabling programmable event-driven workflows.
		Researchers typically analyze GA at the raw data level using batch
		tools to mine and analyze actions, jobs, and steps within GA
		workflows. Although this approach is widely applicable, it ignores
		the specific context of the GA workflow domain. Consequently,
		researchers do not reason directly about the domain abstractions. We
		present our preliminary steps in building EGAD (Explorable GitHub
		Action Domain Model), a moldable domain-specific tool to depict and
		analyze detailed GA workflow data. EGAD consists of an explorable
		domain model of GA workflows augmented with custom, domain-specific
		views, and live narratives. We illustrate EGAD in action using it
		to explore "sticky commits" in GitHub repositories.}
}

@inproceedings{Vale23b,
	Title = {Exploring {GitHub} Actions through {EGAD}: An Experience Report},
	Author = {Pablo Valenzuela-Toledo and Alexandre Bergel and Timo Kehrer and Oscar Nierstrasz},
	Booktitle = {IWST'23: Proceedings of International Workshop on Smalltalk Technologies},
	Note = {To appear},
	Keywords = {seg-pub feenk-pub jb23 MISSING-DOI},
	Url = {http://scg.unibe.ch/archive/papers/Vale23b.pdf},
	Abstract = {GitHub Actions (GA) is an automation and workflow orchestration
		platform that facilitates the execution of software engineering
		tasks. GA supports automation through YAML workflow files, the main
		component for action integration. The workflow files are a valuable
		source of information, for example, to understand how automation
		actions have been orchestrated. To conduct GA studies, researchers
		use batch (non-interactive) tools for analysis. However, this
		approach ignores the context of the GA domain and hinders
		understanding of the intricate pieces that revolve around workflow
		files. We present our experience developing and using EGAD
		(Explorable GitHub Action Domain Model) and share valuable insights
		we gained. Our focus is on three key areas: (i) onboarding of
		Glamorous Toolkit (GT), (ii) creating a comprehensive and explorable
		domain model of GA, and (iii) highlighting the potential of EGAD as a
		research workbench. To facilitate takeaways from these lessons, we
		provide details that showcase our learnings, which researchers can
		apply in their future endeavors. We aim to make this a valuable
		resource for researchers investigating GitHub Actions.},
	Annote = {internationalworkshop},
	Peerreview = {yes},
	location = {Lyon, France},
	Year = {2023},
	Medium = {4}
}

@inproceedings{Kuhn08a,
	Abstract = {To quickly localize defects, we want our attention
				  to be focussed on relevant failing tests. We propose
				  to improve defect localization by exploiting
				  dependencies between tests, using a JUnit extension
				  called JExample. In a case study, a monolithic
				  white-box test suite for a complex algorithm is
				  refactored into two traditional JUnit style tests
				  and to JExample. Of the three refactorings, JExample
				  reports five times fewer defect locations and
				  slightly better performance (-8-12\%), while having
				  similar maintenance characteristics. Compared to the
				  original implementation, JExample greatly improves
				  maintainability due the improved factorization
				  following the accepted test quality guidelines. As
				  such, JExample combines the benefits of test chains
				  with test quality aspects of JUnit style testing.},
	Annote = {internationalconference},
	Author = {Adrian Kuhn and Bart Van Rompaey and Lea H\"ansenberger and Oscar Nierstrasz and Serge Demeyer and Markus Gaelli and Koenraad Van Leemput},
	Booktitle = {Extreme Programming and Agile Processes in Software Engineering, 9th International Conference, XP 2008},
	Doi = {10.1007/978-3-540-68255-4_8},
	Editor = {P. Abrahamsson},
	Isbn = {978-3-540-68254-7},
	Keywords = {scg08 scg-pub snf08 jb08 JExample akuhn gaelli haensenberger},
	Medium = {2},
	Pages = {73--82},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{JExample}: Exploiting Dependencies Between Tests to Improve Defect Localization},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn08aJExample.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn08aJExample.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-68255-4_8}}

@inproceedings{Kurs14b,
	Annote = {internationalconference},
	Author = {Jan Kur\v{s} and Mircea Lungu and Oscar Nierstrasz},
	Title={Bounded Seas: Island Parsing Without Shipwrecks},
	Abstract={ Imprecise manipulation of source code (semi-parsing) is useful for tasks such as robust parsing, error recovery, lexical analysis, and rapid development of parsers for data extraction. An island grammar precisely defines only a subset of a language syntax (islands), while the rest of the syntax (water) is defined imprecisely.
    Usually, water is defined as the negation of islands. Albeit simple, such a definition of water is naive and impedes composition of islands. When developing an island grammar, sooner or later a programmer has to create water tailored to each individual island. Such an approach is fragile, however, because water can change with any change of a grammar. It is time-consuming, because water is defined manually by a programmer and not automatically. Finally, an island surrounded by water cannot be reused because water has to be defined for every grammar individually.
    In this paper we propose a new technique of island parsing - bounded seas. Bounded seas are composable, robust, reusable and easy to use because island-specific water is created automatically. We integrated bounded seas into a parser combinator framework as a demonstration of their composability and reusability.},
	Year={2014},
	Isbn={978-3-319-11244-2},
	Booktitle={Software Language Engineering},
	Volume={8706},
	Series={Lecture Notes in Computer Science},
	Editor={Combemale, Beno\^{i}t and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J.},
	Doi={10.1007/978-3-319-11245-9_4},
	PeerReview = {yes},
	Medium = {2},
	Url = {http://scg.unibe.ch/archive/papers/Kurs14b-BoundedSeas.pdf},
	Publisher={Springer International Publishing},
	Pages={62-81},
	Language={English},
	Keywords = {scg-pub, scg14, jb15, snf-asa1, kursjan},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kurs14b-BoundedSeas.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-319-11245-9_4}}

@incollection{Basi94a,
  title = {The goal question metric approach},
  author = {Victor R Basili and Gianluigi Caldiera and H. Dieter Rombach},
	booktitle = {Encyclopedia of software engineering},
	publisher = {John Wiley \& Sons Inc.},
	editor = {John J. Marciniak},
	pages = {528--532},
	year = {1994}
}

@article{Duca06b,
	Abstract = {Inheritance is well-known and accepted as a
				  mechanism for reuse in object-oriented languages.
				  Unfortunately, due to the coarse granularity of
				  inheritance, it may be difficult to decompose an
				  application into an optimal class hierarchy that
				  maximizes software reuse. Existing schemes based on
				  single inheritance, multiple inheritance, or mixins,
				  all pose numerous problems for reuse. To overcome
				  these problems we propose traits, pure units of
				  reuse consisting only of methods. We develop a
				  formal model of traits that establishes how traits
				  can be composed, either to form other traits, or to
				  form classes. We also outline an experimental
				  validation in which we apply traits to refactor a
				  non-trivial application into composable units.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Oscar Nierstrasz and Nathanael Sch{\"a}rli and Roel Wuyts and Andrew P. Black},
	Cvs = {TraitsTOPLAS2005},
	Doi = {10.1145/1119479.1119483},
	Inria = {hors},
	Issn = {0164-0925},
	Journal = {TOPLAS: ACM Transactions on Programming Languages and Systems},
	Keywords = {scg-pub stefPub snf05 snf06 scg-none jb06 toplas traits onhindex(131) schaerli toplastraits stlit-traits},
	Misc = {SCI impact factor 1.404 (2005)},
	Miscmisc = {was Duca05z},
	Month = mar,
	Number = {2},
	Pages = {331--388},
	Selectif = {oui},
	Title = {Traits: A mechanism for fine-grained reuse},
	Url = {http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf},
	Volume = {28},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1119479.1119483}}

@book{Fowl99a,
	Author = {Martin Fowler and Kent Beck and John Brant and William Opdyke and Don Roberts},
	Keywords = {olit patterns famoos refactoring oorp scglib},
	Publisher = {Addison Wesley},
	Title = {Refactoring: Improving the Design of Existing Code},
	Year = {1999}}

@software{feenk23a,
	author = {{feenk.com}},
	title = {{Glamorous Toolkit} (version 1.0)},
	url = {https://github.com/feenkcom/gtoolkit},
	keywords = {feenk-pub},
	version = {1.0},
	year = {2023}
}

@book{Zelk79b,
	Author = {Marvin Zelkowitz and Alan Shaw and John Gannon},
	Publisher = {Prentice Hall},
	Title = {Principles of Software Engineering and Design},
	Year = {1979}}

@article{Stal81a,
     author = {Stallman, Richard M.},
     title = {EMACS the Extensible, Customizable Self-documenting Display Editor},
     journal = {ACM SIGOA Newsletter},
     issue_date = {Spring/Summer 1981},
     volume = {2},
     number = {1-2},
     month = apr,
     year = {1981},
     issn = {0737-819X},
     pages = {147--156},
     numpages = {10},
     url = {http://doi.acm.org/10.1145/1159890.806466},
     doi = {10.1145/1159890.806466},
     acmid = {806466},
     publisher = {ACM},
     address = {New York, NY, USA}
}

@inproceedings{Haen08b,
	Abstract = {When changing the API of a framework, we need to
				  migrate its clients. This is best done
				  automatically. In this paper, we focus on API
				  migration where the mechanism for inversion of
				  control changes. We propose to use dynamic analysis
				  for such API migration since structural refactorings
				  alone are often not sufficient. We consider JExample
				  as a case-study. JExample extends JUnit with
				  first-class dependencies and fixture injection. We
				  investigate how dynamically collected information
				  about test coverage and about instances under test
				  can be used to detect dependency injection
				  candidates.},
	Annote = {internationalworkshop},
	Author = {Lea H\"ansenberger and Adrian Kuhn and Oscar Nierstrasz},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Haen08bAPImigration.pdf http://swerl.tudelft.nl/bin/view/PCODA/PCODA2008#Proceedings},
	Booktitle = {Proceedings IEEE Workshop on Program Comprehension through Dynamic Analysis (PCODA 2008)},
	Keywords = {scg08 scg-pub skip-doi snf09 jb09 fb08 akuhn haensenberger},
	Medium = {2},
	Month = oct,
	Pages = {32--36},
	Peerreview = {yes},
	Title = {Using Dynamic Analysis for {API} Migration},
	url = {http://scg.unibe.ch/archive/papers/Haen08bAPImigration.pdf},
	url2 = {http://swerl.tudelft.nl/bin/view/PCODA/PCODA2008#Proceedings},
	Year = {2008},
	Bdsk-Url-2 = {http://scg.unibe.ch/archive/papers/Haen08bAPImigration.pdf%20http://swerl.tudelft.nl/bin/view/PCODA/PCODA2008#Proceedings}}

@mastersthesis{Haen09a,
	Abstract = {Unit tests are primarily written as a good practice
				  to support software evolution, i.e., to help
				  developers to identify and fix bugs, to refactor
				  code and to serve as documentation for a unit of
				  software under test. To achieve these benefits, unit
				  tests ideally should cover all possible paths in a
				  program. One unit test usually covers one specific
				  path in one function or method. However, a test
				  method is not necessary an encapsulated, independent
				  entity. Often a test method's coverage is a superset
				  of another test method's coverage set and thus
				  defects are not well isolated, i.e., one defect
				  causes multiple test methods to fail. In this work
				  we present an approach to automatically migrate
				  JUnit test classes to JExample. JExample allows test
				  methods to declare explicit dependencies to other
				  test methods and therefore improves defect
				  isolation. With dynamic analysis we recover the
				  coverage set of each test method and by partially
				  ordering the test methods by means of their coverage
				  sets we derive implicit dependencies between test
				  methods. With program transformation we rewrite the
				  original JUnit test classes as test classes with
				  explicit dependencies between test methods that can
				  be executed with JExample. In a case study on 16
				  projects we found that 72% of all test methods have
				  latent dependencies to other test methods and that
				  by declaring these dependencies defect isolation
				  (measured as average square of failures per defect)
				  could be improved by a factor of 3.77 or higher.},
	Author = {Lea H\"ansenberger},
	Keywords = {scg-msc jb10 scg09 snf09 jexample junit testing haensenberger},
	Month = sep,
	School = {University of Bern},
	Title = {Defect Isolation As Responsibility of the Framework --- Automated {API} Migration from {JUnit} to {JExample}},
	Type = {Master's Thesis},
	Url = {http://scg.unibe.ch/archive/masters/Haen09a.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/masters/Haen09a.pdf}}

@inproceedings{Kuhn08a,
	Abstract = {To quickly localize defects, we want our attention
				  to be focussed on relevant failing tests. We propose
				  to improve defect localization by exploiting
				  dependencies between tests, using a JUnit extension
				  called JExample. In a case study, a monolithic
				  white-box test suite for a complex algorithm is
				  refactored into two traditional JUnit style tests
				  and to JExample. Of the three refactorings, JExample
				  reports five times fewer defect locations and
				  slightly better performance (-8-12\%), while having
				  similar maintenance characteristics. Compared to the
				  original implementation, JExample greatly improves
				  maintainability due the improved factorization
				  following the accepted test quality guidelines. As
				  such, JExample combines the benefits of test chains
				  with test quality aspects of JUnit style testing.},
	Annote = {internationalconference},
	Author = {Adrian Kuhn and Bart Van Rompaey and Lea H\"ansenberger and Oscar Nierstrasz and Serge Demeyer and Markus Gaelli and Koenraad Van Leemput},
	Booktitle = {Extreme Programming and Agile Processes in Software Engineering, 9th International Conference, XP 2008},
	Doi = {10.1007/978-3-540-68255-4_8},
	Editor = {P. Abrahamsson},
	Isbn = {978-3-540-68254-7},
	Keywords = {scg08 scg-pub snf08 jb08 JExample akuhn gaelli haensenberger},
	Medium = {2},
	Pages = {73--82},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{JExample}: Exploiting Dependencies Between Tests to Improve Defect Localization},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn08aJExample.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn08aJExample.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-68255-4_8}}


@phdthesis{Gael06b,
	Abstract = {One of the oldest techniques to explain abstract
				  concepts is to provide concrete examples. By
				  explaining an abstract concept with a concrete
				  example people make sure that the concept is
				  understood and remembered. Examples in software can
				  be used both to test the software and to illustrate
				  its functionality. Object-oriented programs are
				  built around the concepts of classes, methods and
				  variables, where methods are the atoms of the
				  functionality. But the meta-models of
				  object-oriented languages do not allow developers to
				  associate runnable and composable examples with
				  these concepts and particularly not with methods.
				  Unit tests on the other hand, assure the quality of
				  the units under test and document them. Not being
				  integrated into the language, unit tests are not
				  linked explicitly to their units under test which
				  makes it unnecessarily dif ficult to use them for
				  documenting, typing and debugging software. In
				  addition they are not composable making it hard to
				  develop higher level test scenarios in parallel with
				  higher level objects. In this thesis we analyze unit
				  tests to learn about implicit dependencies among
				  tests and from tests to the methods under test. We
				  develop a technique to partially order unit tests in
				  terms of their covered methods, which reveals
				  possible redundancies due to the lack of
				  composability. We show how partial orders can be
				  used to debug and to comprehend software. We then
				  develop a taxonomy based on several case studies
				  revealing that a high fraction of unit tests already
				  implicitly focuses on single methods. We show that
				  the rest of the tests can be decomposed into
				  commands focusing on single methods. We build a
				  meta-model based on our findings of analyzing test
				  interdependencies which establishes how tests can be
				  explicitly linked to their method under test and how
				  they can be composed to form higher-level test
				  scenarios. We explain how the problems of missing
				  links between tests and units under test are solved
				  using our meta-model. Furthermore, we implemented
				  the meta-model and a first user interface on top of
				  it to give first evidence of how our model supports
				  the developer.},
	Author = {Markus Gaelli},
	Cvs = {MGaelliPhD},
	Keywords = {skip-doi scg-phd gaelli scg-none jb07 fb06 snf06},
	Month = nov,
	School = {University of Bern},
	Title = {Modeling Examples to Test and Understand Software},
	Url = {http://scg.unibe.ch/archive/phd/gaelli-phd.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/phd/gaelli-phd.pdf}}

@inproceedings{Gael07a,
	Abstract = {Understanding and maintaining complex software
				  systems is a difficult task. In principle, tests can
				  be a good source of information about how the system
				  works. Unfortunately, tests are frequently
				  unstructured and disconnected from each other and
				  from their units under test. We propose a new
				  approach to organizing unit tests in which tests
				  produce examples of their units under tests which
				  also can be reused for composing higher-level tests.
				  The approach is based on the Eg meta-model, which
				  classifies tests according to their granularity and
				  their goals. We have developed the EgBrowser, an
				  experimental tool for specifying tests that conform
				  to the Eg metamodel while keeping track of the
				  connection between tests themselves and their units
				  under test. Initial usability studies suggest that
				  the approach is both easy to learn and more
				  efficient than the programmatic approach to
				  developing tests.},
	Annote = {internationalconference internationaljournal},
	Author = {Markus Gaelli and Rafael Wampfler and Oscar Nierstrasz},
	Booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
	Cached = {http://scg.unibe.ch/archive/papers/Gael07aComposingTests.pdf},
	Doi = {10.5381/jot.2007.6.9.a4},
	Keywords = {scg07 scg-pub skip-doi snf07 jb08 gaelli},
	Medium = {2},
	Month = oct,
	Pages = {71--86},
	Peerreview = {yes},
	Title = {Composing Tests from Examples},
	url = {http://www.jot.fm/issues/issue_2007_10/paper4.pdf},
	url2 = {http://www.jot.fm/contents/issue_2007_10/paper4.html},
	Volume = {6/9},
	Year = {2007},
	Bdsk-Url-1 = {http://www.jot.fm/issues/issue_2007_10/paper4/index.html%20http://www.jot.fm/issues/issue_2007_10/paper4.pdf}}

@book{Beck00a,
	Author = {Kent Beck},
	Isbn = {201616416},
	Keywords = {olit oorp},
	Publisher = {Addison Wesley},
	Title = {Extreme Programming Explained: Embrace Change},
	Year = {2000}}

@book{Beck03a,
	Author = {Kent Beck},
	Isbn = {0-321-14653-0},
	Keywords = {olit scglib oorp},
	Publisher = {Addison-Wesley},
	Title = {Test Driven Development: By Example},
	Year = {2003}}

@article{Beck94c,
	Author = {Kent Beck},
	Title = {Simple {Smalltalk} Testing: With Patterns},
	Url = {https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm},
  journal={The Smalltalk Report},
  volume={4},
  number={2},
  pages={16--18},
  year={1994}
}

@book{Free09a,
  title={Growing object-oriented software, guided by tests},
  author={Freeman, Steve and Pryce, Nat},
  year = {2009},
  isbn = {0321503627, 9780321503626},
  publisher = {Addison-Wesley Professional}
}

@article{Hell17a,
  title={The {Cucumber} Book: Behaviour-Driven Development for Testers and Developers},
  author={Hellesoy, Aslak},
  year={2017},
  publisher={The Pragmatic Bookshelf}
}

@book{Okke22a,
  title={Python Testing with pytest},
  author={Okken, Brian},
  year={2022},
  publisher={Pragmatic Bookshelf}
}

@inproceedings{Nier24a,
	Annote = {internationalworkshop},
	Author = {Oscar Nierstrasz and Tudor G\^irba},
	Booktitle = {Proceedings of EuroPLoP 2024},
	Keywords = {feenk-pub Girba MISSING-DOI MISSING-ABSTRACT MISSING-URL},
	Title = {Moldable Development Patterns},
	Note = {to appear},
	Year = {2024}
}

@inproceedings{Chis24a,
	Annote = {internationalconference},
	Author = {Andrei Chi\c{s} and Oscar Nierstrasz and Tudor G\^irba},
	Booktitle = {Proceedings of Onward! 2024},
	Keywords = {feenk-pub Girba Chis MISSING-DOI MISSING-ABSTRACT MISSING-URL},
	Title = {Moldable Exceptions},
	Note = {to appear},
	Year = {2024}
}

@article{Knut97a,
    author = {Knuth, D. E.},
    title = {Literate Programming},
    journal = {The Computer Journal},
    volume = {27},
    number = {2},
    pages = {97-111},
    year = {1984},
    month = {01},
    abstract = {The author and his associates have been experimenting for the past several years with a programming language and documentation system called WEB. This paper presents WEB by example, and discusses why the new system appears to be an improvement over previous ones.},
    issn = {0010-4620},
    doi = {10.1093/comjnl/27.2.97},
    url = {https://doi.org/10.1093/comjnl/27.2.97},
    url2 = {https://academic.oup.com/comjnl/article-pdf/27/2/97/981657/270097.pdf}
}

@article{Bush45a,
  title={As we may think},
  author={Bush, Vannevar and others},
  journal={The Atlantic Monthly},
  volume={176},
  number={1},
  pages={101--108},
  year={1945},
  publisher={[S. l.]},
  url = {https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/},
  doi = {10.1145/227181.227186}
}

@inproceedings{Enge68a,
  title={A research center for augmenting human intellect},
  author={Engelbart, Douglas C and English, William K},
  booktitle={Proceedings of the December 9-11, 1968, fall joint computer conference, part I},
  pages={395--410},
  year={1968},
  url = {https://dougengelbart.org/pubs/papers/scanned-original/1968-augment-3954-A-Research-Center-for-Augmenting-Human-Intellect.pdf}
}

@inproceedings{Brag10a,
	Address = {New York, NY, USA},
	Author = {Bragdon, Andrew and Zeleznik, Robert and Reiss, Steven P. and Karumuri, Suman and Cheung, William and Kaplan, Joshua and Coleman, Christopher and Adeputra, Ferdi and LaViola,Jr., Joseph J.},
	Booktitle = {CHI '10: Proceedings of the 28th international conference on Human factors in computing systems},
	Doi = {10.1145/1753326.1753706},
	Isbn = {978-1-60558-929-9},
	Keywords = {codebubbles},
	Location = {Atlanta, Georgia, USA},
	Pages = {2503--2512},
	Publisher = {ACM},
	Title = {Code bubbles: a working set-based interface for code understanding and maintenance},
	Year = {2010},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1753326.1753706}}

@inproceedings{Wren19a,
author = {Wrenn, John and Krishnamurthi, Shriram},
title = {Executable Examples for Programming Problem Comprehension},
year = {2019},
isbn = {9781450361859},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3291279.3339416},
doi = {10.1145/3291279.3339416},
abstract = {Flawed problem comprehension leads students to produce flawed implementations. However, testing alone is inadequate for checking comprehension: if a student develops both their tests and implementation with the same misunderstanding, running their tests against their implementation will not reveal the issue. As a solution, some pedagogies encourage the creation of input-output examples independent of testing-but seldom provide students with any mechanism to check that their examples are correct and thorough.We propose a mechanism that provides students with instant feedback on their examples, independent of their implementation progress. We assess the impact of such an interface on an introductory programming course and find several positive impacts, some more neutral outcomes, and no identified negative effects.},
booktitle = {Proceedings of the 2019 ACM Conference on International Computing Education Research},
pages = {131–139},
numpages = {9},
keywords = {testing, examples, examplar, automated assessment},
location = {Toronto ON, Canada},
series = {ICER '19}
}

@article{Beck98a,
	Author = {Kent Beck and Erich Gamma},
	Journal = {Java Report},
	Keywords = {olit testing JUnit oorp},
	Number = {7},
	Pages = {51--56},
	Title = {Test Infected: Programmers Love Writing Tests},
	Url = {http://members.pingnet.ch/gamma/junit.htm},
	Volume = {3},
	Year = {1998},
	Bdsk-Url-1 = {http://members.pingnet.ch/gamma/junit.htm}}

@inproceedings{Edwa04a,
	Author = {Jonathan Edwards},
	Booktitle = {OOPSLA 04: Companion to the 19th annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
	Doi = {10.1145/1028664.1028713},
	Isbn = {1-58113-833-4},
	Keywords = {visprog subtext},
	Location = {Vancouver, BC, CANADA},
	Pages = {124--124},
	Publisher = {ACM Press},
	Title = {Example centric programming},
	Url = {http://subtextual.org/OOPSLA04.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://subtextual.org/OOPSLA04.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1028664.1028713}}

@inproceedings{Edwa05a,
	Author = {Jonathan Edwards},
	Booktitle = {Proceedings of the 20th Annual {ACM} {SIGPLAN} Conference on Object-Oriented Programming, Systems, Languages, and Applications, {OOPSLA} 2005, October 16-20, 2004, San Diego, {CA}, {USA}},
	Doi = {10.1145/1094811.1094851},
	Editor = {Ralph Johnson and Richard P. Gabriel},
	Isbn = {1-59593-031-0},
	Keywords = {visprog subtext},
	Pages = {505--518},
	Publisher = {ACM},
	Title = {Subtext: uncovering the simplicity of programming},
	Url = {http://subtextual.org/OOPSLA05.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://subtextual.org/OOPSLA05.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1094811.1094851}}

@inproceedings{Kava23a,
author = {Kavalar, Martin and Markovics, Philippa and Rusher, Jack},
title = {Clerk: Moldable Live Programming for {Clojure}},
year = {2023},
isbn = {9798400707551},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3594671.3594682},
doi = {10.1145/3594671.3594682},
abstract = {Clerk is an open source Clojure programmer’s assistant that builds upon the traditions of interactive and literate programming to provide a holistic moldable development environment. Clerk layers static analysis, incremental computation, and rich browser-based graphical presentations on top of a Clojure programmer’s familiar toolkit to enhance their workflow.},
booktitle = {Companion Proceedings of the 7th International Conference on the Art, Science, and Engineering of Programming},
pages = {22–31},
numpages = {10},
keywords = {clojure, lisp, literate programming, live programming, moldable development, notebooks},
location = {Tokyo, Japan},
series = {Programming '23}
}

